{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Flask-mailing","text":"<p>Flask-Mailing is a highly efficient and user-friendly package that enables <code>Asynchronous</code> email messaging in Flask applications. Asynchronous email messaging is becoming increasingly popular because it allows applications to continue running while emails are being sent in the background. This makes it an ideal solution for time-sensitive applications that require a fast and responsive user experience.</p> <p>With Flask-Mailing, developers can easily integrate asynchronous email messaging capabilities into their Flask applications without the need for complex configurations or additional dependencies. The package offers a variety of features, including support for multiple email providers, email templates, and error handling. It also supports common email protocols, such as <code>SMTP</code>, <code>SSL</code>, and <code>TLS</code>.</p> <p>Moreover, Flask-Mailing offers a simple and intuitive API that allows developers to easily send emails in the background. It also provides advanced features, such as email tracking and reporting, which enable developers to monitor email performance and user engagement.</p> <p>Whether you're building a small-scale application or a large-scale enterprise system, Flask-Mailing provides a reliable and scalable solution for Asynchronous email messaging in Flask applications.</p> <p>Flask-Mail has been discontinued. However, you can still use email services with your Flask projects by using either Flask-Mailing for asynchronous implementation or Flask-Mailman for synchronous implementation.</p> <ul> <li> <p>Flask-Mailing supports asynchronous email sending using the built-in <code>asyncio</code> library in Python 3.5+. It easily integrates with Flask applications using the provided <code>Mail</code> extension, offers simple and intuitive configuration options for email providers, supports HTML and plain-text message formats, and provides options for customizing email headers and message priority levels. It also includes customizable email templates, supports file attachments, and allows for bulk email sending, email tracking, encryption and authentication, error handling, and logging functionality.</p> </li> <li> <p>Flask-Mailman, on the other hand, provides a simple API for sending email messages synchronously, supports HTML and plain-text message formats, allows for customizing email headers and message priority levels, and provides options for email tracking and error handling. It also includes customizable email templates and supports file attachments.</p> </li> </ul> <p>Choose the package that best fits your project's requirements and start using email services with your Flask application!</p> <p>Flask_Mail is dead now. To use the mail service with your project you can use eaither Flask-Mailing for Asynchronous or Flask-Mailman for Synchronous implementation.</p> <p> </p>"},{"location":"#a-basic-demo-for-better-understanding","title":"A Basic Demo for better understanding","text":"<pre><code>from flask import Flask, jsonify\nfrom flask_mailing import Mail, Message\n\nmail = Mail()\n\ndef create_app():\n    app = Flask(__name__)\n\n\n    app.config['MAIL_USERNAME'] = \"your-email@your-domain.com\"\n    app.config['MAIL_PASSWORD'] = \"world_top_secret_password\"\n    app.config['MAIL_PORT'] = 587\n    app.config['MAIL_SERVER'] = \"your-email-server.com\"\n    app.config['MAIL_USE_TLS'] = True\n    app.config['MAIL_USE_SSL'] = False\n    app.config['MAIL_DEFAULT_SENDER'] = \"your-email@your-domain.com\"\n    mail.init_app(app)\n\n    return app\n\n#send a simple email using flask_mailing module.\n\napp = create_app()\n\n@app.get(\"/email\")\nasync def simple_send():\n\n    message = Message(\n        subject=\"Flask-Mailing module\",\n        recipients=[\"aniketsarkar@yahoo.com\"],\n        body=\"This is the basic email body\",\n        )\n\n\n    await mail.send_message(message)\n    return jsonify(status_code=200, content={\"message\": \"email has been sent\"})\n</code></pre>"},{"location":"#using-jinja2-html-templates","title":"Using Jinja2 HTML Templates","text":"<p>In order to use Jinja template langauge, your must specify email folder within your applications working directory.</p> <p>In sending HTML emails, the CSS expected by mail servers -outlook, google, etc- must be inline CSS. Flask mail passes \"body\" to the rendered template. In creating the template for emails the dynamic objects should be used with the assumption that the variable is named \"body\" and that it is a python dict.</p> <p>check out jinja2 for more details  jinja2</p>"},{"location":"#guide-for-email-utils","title":"Guide for Email Utils","text":"<p>The utility allows you to check temporary email addresses, you can block any email or domain.  You can connect Redis to save and check email addresses. If you do not provide a Redis configuration,  then the utility will save it in the list or set by default.</p>"},{"location":"#writing-unittests-using-flask-mailing","title":"Writing unittests using Flask-Mailing","text":"<p>Flask mails allows you to write unittest for your application without sending emails to non existent email address by mocking the email to be sent. To mock sending out mails, set the suppress configuraton to true. Suppress send defaults to False to prevent mocking within applications.</p>"},{"location":"#support-for-reply-to-header-is-added","title":"Support for Reply-To header is added","text":"<p>Use this just like bcc but to specify addresses that should receive a reply to your message. E-mail systems MAY respect this as per RFC 2822.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#002","title":"0.0.2","text":"<ul> <li>Update dependencies</li> </ul>"},{"location":"changelog/#004","title":"0.0.4","text":"<ul> <li>added setup details to pyproject.toml file to solve the dependency error.</li> </ul>"},{"location":"changelog/#005","title":"0.0.5","text":"<ul> <li>Added one more config variable named <code>MAIL_DEFAULT_SENDER</code>. It's as same as <code>MAIL_FROM</code> config var.</li> <li>Fixed absent of <code>httpx</code> module at the setup.py file.</li> <li>Config var <code>MAIL_SSL</code> and <code>MAIL_TLS</code> changes to <code>MAIL_USE_SSL</code> and <code>MAIL_USE_TLS</code> accordingly.</li> <li>added <code>add_recipient</code> and <code>attach</code> method to the schemas.Message class.</li> <li>Fixed some broken test cases.</li> <li>modifications at the documentation.</li> </ul>"},{"location":"changelog/#006","title":"0.0.6","text":"<ul> <li>Now the user can access the <code>Mail</code> object from the app extension dictionary: <code>app.extension['mailing']</code></li> </ul>"},{"location":"changelog/#007","title":"0.0.7","text":"<ul> <li><code>Fixed</code> the <code>long description not found</code> on the PYPI website.</li> </ul>"},{"location":"changelog/#010","title":"0.1.0","text":"<ul> <li><code>Fixed</code> issue #20 . Now the user can pass template parameters by using <code>template_params</code> variable on the <code>schemas.Message</code> class.</li> <li><code>Fixed</code> major typo at setup.py</li> <li><code>Fixed</code> some broken test cases.</li> <li><code>Fixed</code> the Variable name issue at <code>config.ConnectionConfig</code> class.</li> <li> <p><code>Fixed</code> Literal import for Python 3.6 and 3.7</p> </li> <li> <p><code>Added</code> module docstring.</p> </li> <li><code>Added</code> <code>future roadmap</code> on the docs.</li> <li><code>Added</code> some more test cases.</li> <li><code>Added</code> the compatibility for Python 3.10</li> <li> <p><code>Added</code> the feature to allow users to create custom headers for attachments.</p> </li> <li> <p><code>Updated</code> the <code>MANIFEST.in</code> file.</p> </li> <li><code>Updated</code> the required dependencies.</li> </ul>"},{"location":"changelog/#011","title":"0.1.1","text":"<ul> <li><code>Fixed</code> broken test cases for fake redis client.</li> <li><code>Fixed</code> some typo at <code>utils.email_check</code> file.</li> <li><code>Added</code> <code>aioredis &gt; 2.0.0</code> compatibility.</li> <li><code>Added</code> fully asynchronous support for <code>utils.email_check.EmailChecker</code> class.</li> <li><code>Updated</code> the <code>utils.email_check.EmailChecker</code> class for the new version of <code>aioredis</code>.</li> <li><code>Updated</code> the required dependencies.</li> </ul>"},{"location":"changelog/#020","title":"0.2.0","text":"<ul> <li><code>Added</code> <code>send_mail</code>, <code>send_mass_mail</code> methods very similar to <code>Django</code> or <code>Flask-Mailman</code>.</li> <li><code>Added</code> more docstrings for better understanding of all the apis.</li> <li><code>Added</code> few more test cases.</li> <li><code>Fixed</code> major bug at <code>MAIL_START_TLS</code>/<code>MAIL_START_SSL</code> configuration at <code>ConnectionConfig</code>.</li> </ul>"},{"location":"changelog/#021","title":"0.2.1","text":"<ul> <li><code>Fixed</code> aioredis issue with python 3.11.    </li> <li><code>Fixed</code> httpx library issue.  </li> </ul>"},{"location":"changelog/#022","title":"0.2.2","text":"<ul> <li><code>Updated</code> setup.py. </li> <li><code>Updated</code> Readme file. </li> <li><code>Fixed</code> version number issue. </li> <li><code>Added</code> the compatibility for Python 3.11. </li> </ul>"},{"location":"changelog/#023","title":"0.2.3","text":"<ul> <li><code>Added</code> compatibility for Pydantic V2.</li> <li><code>Fixed</code> several bugs.</li> </ul>"},{"location":"contribute/","title":"Contributing to flask-mailing","text":"<p>We welcome contributions to flask-mailing</p>"},{"location":"contribute/#issues","title":"Issues","text":"<p>Feel free to submit issues and enhancement requests.</p> <p>Flask-Mailing Issues</p>"},{"location":"contribute/#contributing","title":"Contributing","text":"<p>Please refer to each project's style and contribution guidelines for submitting patches and additions. In general, we follow the \"fork-and-pull\" Git workflow.</p> <ol> <li>Fork the repo on GitHub</li> <li>Clone the project to your own machine</li> <li>Commit changes to your own branch</li> <li>Push your work </li> <li>Submit a Pull request so that we can review your changes</li> </ol> <p>NOTE: Be sure to merge the latest from <code>upstream</code> before making a pull request!</p>"},{"location":"example/","title":"Example","text":""},{"location":"example/#sending-emails-using-flask-mailing","title":"Sending emails using Flask-Mailing","text":""},{"location":"example/#list-of-examples","title":"List of Examples","text":""},{"location":"example/#basic-configuration","title":"Basic configuration","text":"<pre><code>from flask import Flask, jsonify\nfrom flask_mailing import Mail, Message\n\nmail = Mail()\n\ndef create_app():\n    app = Flask(__name__)\n\n\n    app.config['MAIL_USERNAME'] = \"your-email@your-domain.com\"\n    app.config['MAIL_PASSWORD'] = \"world_top_secret_password\"\n    app.config['MAIL_PORT'] = 587\n    app.config['MAIL_SERVER'] = \"your-email-server.com\"\n    app.config['MAIL_USE_TLS'] = True\n    app.config['MAIL_USE_SSL'] = False\n    mail.init_app(app)\n\n    return app\n\n#send a simple email using flask_mailing module.\n\napp = create_app()\n\n@app.get(\"/email\")\nasync def simple_send():\n\n    message = Message(\n        subject=\"Flask-Mailing module\",\n        recipients=[\"aniketsarkar@yahoo.com\"],\n        body=\"This is the basic email body\",\n        )\n\n\n    await mail.send_message(message)\n    return jsonify(status_code=200, content={\"message\": \"email has been sent\"})\n</code></pre>"},{"location":"example/#add-recipient-using-add_recipient-method","title":"Add recipient using <code>add_recipient</code> method","text":"<pre><code>message.add_recipient(\"recipient@emldomain.com\")\n</code></pre>"},{"location":"example/#send-a-simple-html-message","title":"Send a simple html message","text":"<pre><code>html = \"\"\"\n&lt;p&gt;Hi this test mail, thanks for using Flask-Mailing&lt;/p&gt; \n\"\"\"\n\n@app.get(\"/html-email\")\nasync def html_email():\n\n    message = Message(\n        subject=\"Flask-Mailing module test html mail\",\n        recipients=[\"aniketsarkar@yahoo.com\"],\n        body=html,\n        subtype=\"html\"\n        )\n\n\n    await mail.send_message(message)\n    return jsonify(status_code=200, content={\"message\": \"email has been sent\"})\n</code></pre>"},{"location":"example/#sending-files","title":"Sending files","text":"<pre><code>@app.get(\"/mail-file\")\nasync def mail_file():\n    message = Message(\n        subject = \"attachments based email\",\n        recipients = [\"aniketsarkar@yahoo.com\"],\n        body = \"email with attachments, email body.\",\n        attachments = ['attachments/attachment.txt']\n    )\n    await mail.send_message(message)\n    return jsonify(message=\"email sent\")\n</code></pre>"},{"location":"example/#sending-files-using-attach-method","title":"Sending files using <code>attach</code> method","text":"<pre><code>with app.open_resource(\"attachments/example.txt\") as fp:\n    message.attach(\"example.txt\", fp.read())\n</code></pre>"},{"location":"example/#using-jinja2-html-templates","title":"Using Jinja2 HTML Templates","text":"<p>You can enable Jinja2 HTML Template emails by setting the <code>TEMPLATE_FOLDER</code> configuration option, and supplying a value (which is just the name of the template file within the <code>TEMPLATE_FOLDER</code> dir) for the <code>template_name</code> parameter in <code>Mail.send_message()</code>. You then can pass a Dict as the <code>template_body</code> property of your <code>Message</code> object. If you haven't provided the <code>TEMPLATE_FOLDER</code> configuration option, then the module will take the app's jinja2 environment for templating and you can use templates from app's default template folder:</p> <p><pre><code>from pathlib import Path\n\napp.config[\"TEMPLATE_FOLDER\"] = Path(__file__).parent / 'email-templates'\n\"\"\"\nDon't use this configuration if you want to use the default jinja2 environment.\n\"\"\"\n@app.get(\"/mail-html\")\nasync def mail_html():\n\n    message = Message(\n        subject = \"html template based email\",\n        recipients = [\"aniketsarkar@yahoo.com\"],\n        template_body = {\n                        \"first_name\": \"Hare\",\n                        \"last_name\": \"Krishna\"\n                        }\n        # attachments = ['attachments/attachment.txt']\n    )\n    #or\n    message = Message(\n        subject = \"html template based email\",\n        recipients = [\"aniketsarkar@yahoo.com\"],\n        template_params = {\n                        \"first_name\": \"Hare\",\n                        \"last_name\": \"Krishna\"\n                        }\n        # attachments = ['attachments/attachment.txt']\n    )\n\n    await mail.send_message(message, template_name=\"test.html\")\n    return jsonify(message=\"email sent\")\n</code></pre> For example, assume we pass a <code>template_body</code> of: <pre><code>{\n  \"first_name\": \"Hare\",\n  \"last_name\": \"Krishna\"\n}\n</code></pre> We can reference the variables in our Jinja templates as per normal: <pre><code>...\n&lt;span&gt;Hello, {{ first_name }}!&lt;/span&gt;\n...\n</code></pre></p>"},{"location":"example/#legacy-behaviour","title":"Legacy Behaviour","text":"<p>The original behaviour was to wrap the Dict you provide in a variable named <code>body</code> when it was provided to  Jinja behind the scenes. In these versions, you can then access your dict in your template like so:</p> <pre><code>...\n&lt;span&gt;Hello,  body.first_name !&lt;/span&gt;\n...\n</code></pre> <p>As you can see our keys in our dict are no longer the top level, they are part of the <code>body</code> variable. Nesting works  as per normal below this level also. </p>"},{"location":"example/#customizing-attachments-by-headers-and-mime-type","title":"Customizing attachments by headers and MIME type","text":"<p>Used for example for referencing Content-ID images in html of email</p> <pre><code>message = Message(\n    subject='Flask-Mailing module',\n    recipients=recipients,\n    html=\"&lt;img src='cid:logo_image'&gt;\",\n    subtype='html',\n    attachments=[\n            {\n                \"file\": \"/path/to/file.png\"),\n                \"headers\": {\"Content-ID\": \"&lt;logo_image&gt;\"},\n                \"mime_type\": \"image\",\n                \"mime_subtype\": \"png\",\n            }\n        ],\n)\n\nawait mail.send_message(message)\n</code></pre>"},{"location":"example/#guide-for-email-utils","title":"Guide for email utils","text":"<p>The utility allows you to check temporary email addresses, you can block any email or domain.  You can connect Redis to save and check email addresses. If you do not provide a Redis configuration,  then the utility will save it in the list or set by default.</p>"},{"location":"example/#check-dispasoble-email-address","title":"Check dispasoble email address","text":"<pre><code>async def default_checker():\n    checker = DefaultChecker()  # you can pass source argument for your own email domains\n    await checker.fetch_temp_email_domains() # require to fetch temporary email domains\n    return checker\n\n@app.get('/email/dispasoble')\nasync def simple_send():\n    domain = \"gmail.com, \n    checker = await default_checker()\n    if await checker.is_dispasoble(domain):\n        return jsonify(status_code=400, content={'message': 'this is dispasoble domain'})\n\n    return jsonify(status_code=200, content={'message': 'email has been sent'})\n</code></pre>"},{"location":"example/#add-dispasoble-email-address","title":"Add dispasoble email address","text":"<pre><code>@app.get('/email/dispasoble')\nasync def add_disp_domain():\n    domains: list = [\"gmail.com\"]\n    checker: DefaultChecker = await default_checker()\n\n    res = await checker.add_temp_domain(domains)\n\n    return jsonify(status_code=200, content={'result': res})\n</code></pre>"},{"location":"example/#add-domain-to-blocked-list","title":"Add domain to blocked list","text":"<pre><code>@app.get('/email/blocked/domains')\nasync def block_domain():\n    domain: str = \"gmail.com\"\n    checker: DefaultChecker = await default_checker()\n\n    await checker.blacklist_add_domain(domain)\n\n    return jsonify(status_code=200, content={'message': f'{domain} added to blacklist'})\n</code></pre>"},{"location":"example/#check-domain-blocked-or-not","title":"Check domain blocked or not","text":"<pre><code>@app.get('/email/blocked/check-domains')\nasync def get_blocked_domain():\n    domain: str ='gmail.com'\n    checker: DefaultChecker = await default_checker()\n    res = await checker.is_blocked_domain(domain)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#add-email-address-to-blocked-list","title":"Add email address to blocked list","text":"<pre><code>@app.get('/email/blocked/address')\nasync def block_address():\n    email: str ='hacker@gmail.com'\n    checker: DefaultChecker = await default_checker()\n    await checker.blacklist_add_email(email)\n\n    return jsonify(status_code=200, content={\"result\": True})\n</code></pre>"},{"location":"example/#check-email-blocked-or-not","title":"Check email blocked or not","text":"<pre><code>@app.get('/email/blocked/address')\nasync def get_block_address():\n    email: str ='hacker@gmail.com'\n    checker: DefaultChecker = await default_checker()\n    res = await checker.is_blocked_address(email)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#check-mx-record","title":"Check MX record","text":"<pre><code>@app.get(\"/email/check-mx\")\nasync def check_mx_record():\n    checker = await default_checker()\n    domain = \"gmail.com\"\n    res = await checker.check_mx_record(domain, False)\n\n    return jsonify(status_code=200, content={'result': res})\n</code></pre>"},{"location":"example/#remove-email-address-from-blocked-list","title":"Remove email address from blocked list","text":"<pre><code>@app.get('/email/blocked/address')\nasync def del_blocked_address():\n    checker = await default_checker()\n    email = \"hacker@gmail.com\"\n    res = await checker.blacklist_rm_email(email)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#remove-domain-from-blocked-list","title":"Remove domain from blocked list","text":"<pre><code>@app.get('/email/blocked/domains')\nasync def del_blocked_domain():\n    checker = await default_checker()\n    domain = \"gmail.com\"\n    res = await checker.blacklist_rm_domain(domain)\n\n    return jsonify(status_code=200, content={\"result\": res})\n</code></pre>"},{"location":"example/#remove-domain-from-temporary-list","title":"Remove domain from temporary list","text":"<pre><code>@app.get('/email/dispasoblee')\nasync def del_disp_domain():\n    checker = await default_checker()\n    domains = [\"gmail.com\"]\n    res = await checker.blacklist_rm_temp(domains)\n\n    return jsonify(status_code=200, content={'result': res})\n</code></pre>"},{"location":"example/#whoisxmlapi","title":"WhoIsXmlApi","text":"<pre><code>from flask_mailing.utils import WhoIsXmlApi\n\nwho_is = WhoIsXmlApi(token=\"Your access token\", email=\"your@mailaddress.com\")\n\nprint(who_is.smtp_check_())    #check smtp server\nprint(who_is.is_dispasoble()) # check email is disposable or not\nprint(who_is.check_mx_record()) # check domain mx records \nprint(who_is.free_check) # check email domain is free or not\n</code></pre>"},{"location":"getting-started/","title":"\ud83d\udd79 Getting Started","text":""},{"location":"getting-started/#guide","title":"\ud83d\udd79 Guide","text":"<p>After installing the module and setting up your <code>Flask</code> app:</p> <p>Main classes and packages are <code>Mail</code> <code>Message</code> <code>utils.DefaultChecker</code> <code>utils.WhoIsXmlApi</code></p>"},{"location":"getting-started/#available-config-options","title":"Available config options","text":"<p>class has following attributes</p> <ul> <li>MAIL_USERNAME  : Username for email, some email hosts separates username from the default sender(AWS).<ul> <li>If you service does not provide username use sender address for connection.</li> </ul> </li> <li>MAIL_PASSWORD : Password for authentication</li> <li>MAIL_SERVER  : SMTP Mail server.</li> <li>MAIL_USE_TLS : For TLS connection</li> <li>MAIL_USE_SSL : For SSL connection</li> <li>MAIL_DEBUG : Debug mode for while sending mails, defaults 0.</li> <li>MAIL_FROM : Sender address</li> <li>MAIL_DEFAULT_SENDER : Sender address</li> <li>MAIL_FROM_NAME : Title for Mail</li> <li>TEMPLATE_FOLDER: If you are using jinja2, specify template folder name</li> <li>SUPPRESS_SEND:  To mock sending out mail, defaults 0.</li> <li>USE_CREDENTIALS: Defaults to <code>True</code>. However it enables users to choose whether or not to login to their SMTP server.</li> <li>VALIDATE_CERTS: Defaults to <code>True</code>. It enables to choose whether to verify the mail server's certificate</li> </ul>"},{"location":"getting-started/#mail-class","title":"<code>Mail</code> class","text":"<p>class has following attributes and methods</p> <ul> <li> <p><code>send_message</code> : The methods has two atributes, message: Message, template_name=None</p> <ul> <li>message : where you define message sturcture for email</li> <li>template_name : if you are using jinja2 consider template_name as well for passing HTML.</li> </ul> </li> <li> <p><code>send_mail</code> : sending emails with message string and recipients very similar to Django.</p> <ul> <li>subject : A String containing the subject of the message.</li> <li>message : A string containing the message body.</li> <li>recipients : A list of strings, each an email address. Each member of recipients will see the other recipients in the \u201cTo:\u201d field of the email message.</li> <li>msgkwargs : the kwargs based parameters for <code>Message</code> class.</li> </ul> </li> <li> <p><code>send_mass_mail</code> : To handle mass mailing.</p> <ul> <li>datatuple : is a tuple in which each element is in this format:     <pre><code>(subject, message, recipients)\n</code></pre></li> </ul> </li> </ul>"},{"location":"getting-started/#message-class","title":"<code>Message</code> class","text":"<p>class has following attributes</p> <ul> <li>recipients  : List of recipients.</li> <li>attachments : attachments within mail.</li> <li>subject  : subject content of the mail.</li> <li>body : body of the message.</li> <li>template_body: parameters for the jinja template.</li> <li>template_params: parameters for the jinja template.</li> <li>cc : cc recipients of the mail.</li> <li>bcc : bcc recipients of the mail.</li> <li>reply_to : Reply-To recipients in the mail.</li> <li>charset : charset defaults to utf-8.</li> <li>subtype : subtype of the mail defaults to plain.</li> <li>add_recipient : a method to add additional recipients.</li> <li>attach : a method to add additional attachments.</li> </ul>"},{"location":"getting-started/#utilsdefaultchecker-class","title":"<code>utils.DefaultChecker</code> class","text":"<p>Default class for checking email from collected public resource. The class makes it possible to use redis to save data.</p> <ul> <li>source  : <code>optional</code> source for collected email data.</li> <li>db_provider  : switch to redis</li> </ul>"},{"location":"getting-started/#utilswhoisxmlapi-class","title":"<code>utils.WhoIsXmlApi</code> class","text":"<p>WhoIsXmlApi class provide working with api  WhoIsXmlApi This service gives free 1000 request to checking email address per month.</p> <ul> <li>token  : token you can get from this WhoIsXmlApi link</li> <li>email  : email for checking</li> </ul>"},{"location":"install/","title":"\ud83d\udd28 Installation","text":""},{"location":"install/#using-pip","title":"Using pip","text":"<pre><code>python3 -m venv .venv\n\nsource .venv/bin/activate\n\npip install flask-mailing\n</code></pre>"},{"location":"install/#using-source-code","title":"Using source code","text":"<pre><code>git clone https://github.com/marktennyson/flask-mailing &amp;&amp; cd flask-mailing\npython3 setup.py install\n</code></pre>"}]}